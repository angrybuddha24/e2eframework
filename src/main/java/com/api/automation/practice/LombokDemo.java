package com.api.automation.practice;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.EqualsAndHashCode;
import lombok.NoArgsConstructor;

/* References 
https://www.javatpoint.com/lombok-java 
http://www.javabyexamples.com/delombok-allargsconstructor-noargsconstructor-and-requiredargsconstructor 
*/

/* The project Lombok is a popular and widely used Java library that is used to minimize or remove the boilerplate code. 
It saves time and effort. Just by using the annotations, we can save space and readability of the source code. */

/* Java Lombok Package
The package contains all the annotations and classes required to use Lombok. All other packages are only applicable to those who are extending Lombok for their own uses, except the following two packages:

lombok.extern.*: The packages contain Lombok annotations that are useful to reduce boilerplate issues for libraries. It is not part of the JRE itself.
lombok.experimental: The package contains Lombok features that are new or likely to change before committing to long-term support. */

/* Annotations can be used above the class/variable declaration or after the access specifier as part of Class/Variable declaration */

/* @Data - Generates getters, setters for all fields, a useful toString method, and hashCode and equals implementations that check all non-transient fields.
Generally, we must use @Data for mutable classes whose internal state can change over time.*/

/* @Value is similar to the @Data annotation, but it creates immutable objects. It adds the followong annotations internally
@Getter
@FieldDefaults(makeFinal = true, level = AccessLevel.PRIVATE)
@AllArgsConstructor
@EqualsAndHashCode
@ToString

Since we use @Value mainly to create immutable objects, Lombok marks the class as final and the instance variables as private final. However, this isn't a strict rule.
Firstly, we can change the access modifiers of the fields using @NonFinal and @PackagePrivate:
*/

/* @AllArgsConstructor: This annotation is used to generate a parameterized constructor which accepts a single parameter for each field and initializes them using it. 
It is required when you want to generate an object of the class by passing the initial values of the fields in the constructor.  */

/* @NoArgsConstructor: This annotation is used to generate a constructor with no arguments. It has an empty body and does nothing. 
It is generally used in combination with some other parameterized constructor in use. 
It is required when you want to generate an object of the class by passing no arguments in the constructor.  */

/* @EqualsAndHashCode.Exclude - exclude the fields using the annotation, so that it isn't considered during hash value calculation.  */

/* @RequiredArgsConstructor generates a constructor requiring an argument for the final and @NonNull fields. 
It won't allow the user to invoke setter on the field since it's final. */

/* If we are going to specify a getter or setter manually, then it will override the default getter/setter generated by lombok */

/* When we annotate a class with @Builder, Lombok creates a builder for all instance fields in that class.
It generates a Constructor with all arguments, an inner static builder class, package-private constructor, Constructors with individual fields,
a Class instance with the build() method and a toString() method 

@Builder can be invoked on Class Level, Constructor Level, Method Level, Collection-Valued Fields (along with @Singular) and Default values (along with @Builder.Default)*/

/* Points to remember
As a rule, Java requires subclasses to call one of the superclass constructors during construction. 
So, if the superclass doesn't have a no-args constructor, Lombok can't generate any constructor in the subclass. */

@Data
@AllArgsConstructor
@NoArgsConstructor
@Builder
public class LombokDemo {

    private String name;
    private @EqualsAndHashCode.Exclude int age;
    @Builder.Default
    private boolean isStudent = true;

}
